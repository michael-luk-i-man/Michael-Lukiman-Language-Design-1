%{
#include <iostream>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    int val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog
%token program
%token line
%token statement
%token expr-list 
%token var-list
%token expression
%token term
%token factor
%token number
%token DIGIT
%token VAR
%token LPAREN RPAREN
%token PLUMIN
%token STRING
%token COMMA
%token CR
%type <val> expr

%token <val> NUM    /* 'val' is the (only) field declared in %union
                       which represents the type of the token. */


/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left PLUS MINUS    /* left means left-associativity. */
%left DIV MUL

%%

program:	line program                            { std::cout << $1 << std::endl; } ;

line:		number statement CR
	|	statement CR
	;

statement:	PRINT expr_list
	|	IF expression RELOP expression THEN statement
	|	GOTO expression
	|	INPUT var_list
	|	LET VAR = expression
	| 	GOSUB expression
	|	RETURN
	| 	CLEAR
	| 	LIST
	| 	RUN    	 | LPAREN expr RPAREN               { $$ = $2; }

	|	END
	;

expr_list:	strexp COMMA expr_list
	|	strexp
	;

strexp:		STRING
      	|	expression

expression:	PLUMIN term expression
	|	PLUMIN term
	;

term:		factor MULDIV term  
	|	factor
	;

factor:		VAR
      	|	number
	|	LPAREN expression RPAREN
	;

number:		DIGIT number 
      	|	/*eps*/

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}

